/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.6
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

/**
 * @file	FSPDFGraphicsObject.h
 * @brief	This file contains definitions of object-c APIs for Foxit PDF SDK.
 */

#import "FSCommon.h"
/**
 * @brief   Enumeration for PDF graphics object type.
 *
 * @details Values of this enumeration should be used alone.
 */
enum FS_GRAPHICSOBJECTTYPE {
    /** @brief	Represents all graphics object types, only used as filter. */
    e_graphicsObjTypeAll = 0,
    /** @brief  Text graphics object. */
    e_graphicsObjTypeText = 1,
    /** @brief  Path graphics object. */
    e_graphicsObjTypePath = 2,
    /** @brief  Image graphics object. */
    e_graphicsObjTypeImage = 3,
    /** @brief  Shading graphics object. */
    e_graphicsObjTypeShading = 4,
    /** @brief  Form XObject graphics object. */
    e_graphicsObjTypeFormXObject = 5
};

/**
 * @brief   Enumeration for filling mode types.
 *
 * @details Values of this enumeration should be used alone.
 */
enum FS_FILLMODE {
    /** @brief  Fill mode: none. */
    e_fillModeNone = 0,
    /**
     * @brief   Alternate fill mode.
     *
     * @details Represent a fill mode in which the system fills this area between odd-numbered and even-numbered polygon
     *          sides on each scan line.
     */
    e_fillModeAlternate = 1,
    /**
     * @brief   Winding fill mode.
     *
     * @details Represent a fill mode in which the system uses a direction in which a figure is drawn to determine
     *          whether to fill an area.
     */
    e_fillModeWinding = 2
};

/**
 * @brief   Enumeration for render blend mode.
 *
 * @details Values of this enumeration should be used alone.
 */
enum FS_RENDERBLENDMODE {
    /**
     * @brief   Selecting source color and ignoring backdrop color.
     *
     * @details Here is the formula :<br>
     *          B(Cb, Cs) = Cs.<br>
     */
    e_renderBlendNormal = 0,
    /**
     * @brief   Multiply backdrop by source color values.
     *
     * @details Here is the formula :<br>
     *          B(Cb, Cs) = Cb * Cs.
     */
    e_renderBlendMultiply = 1,
    /**
     * @brief   Multiply complements of backdrop by source color values, and then complement the result.
     *
     * @details Here is the formula :<br>
     *          B(Cb, Cs) = 1 - [(1 - Cb) * (1 - Cs)] = Cb + Cs - Cb * Cs.
     */
    e_renderBlendScreen = 2,
    /**
     * @brief   Multiply or screens colors, depending on backdrop color value.
     *
     * @details Here is the formula :<br>
     *          B(Cb, Cs) = HardLight(Cs, Cb).
     */
    e_renderBlendOverlay = 3,
    /**
     * @brief   Select darker one of backdrop and source colors.
     *
     * @details Here is the formula :<br>
     *          B(Cb, Cs) = min(Cb, Cs).
     */
    e_renderBlendDarken = 4,
    /**
     * @brief   Select lighter one of backdrop and source colors.
     *
     * @details Here is the formula :<br>
     *          B(Cb, Cs) = max(Cb, Cs).
     */
    e_renderBlendLighten = 5,
    /**
     * @brief   Brightens backdrop color to reflect source colors.
     *
     * @details Painting with black produces no changes.<br>
     *          Here is the formula :<br>
     *          B(Cb, Cs) = <br>
     *          - min(1, Cb / (1 - Cs))     if Cs < 1 <br>
     *          - 1                         if Cs = 1
     */
    e_renderBlendColorDodge = 6,
    /**
     * @brief   Darkens backdrop color to reflect the source color.
     *
     * @details Painting with white produces no changes.<br>
     *          Here is the formula :<br>
     *          B(Cb, Cs) =  <br>
     *          - 1 - min(1, (1 - Cb) / Cs) if Cs > 0 <br>
     *          - 0                         if Cs = 0
     */
    e_renderBlendColorBurn = 7,
    /**
     * @brief   Multiply or screens colors, depending on source color value.
     *
     * @details Here is the formula :<br>
     *          B(Cb, Cs) =  <br>
     *          - Multiply(Cb, 2 * Cs)      if Cs <= 0.5 <br>
     *          - Screen(Cb, 2 * Cs - 1)    if Cs > 0.5
     */
    e_renderBlendHardlight = 8,
    /**
     * @brief   Darkens or lightens colors, depending on source color value.
     *
     * @details Here is the formula :<br>
     *          B(Cb, Cs) =  <br>
     *          - Cb - (1 - 2 * Cs) * Cb * (1 - Cb)     if Cs <= 0.5 <br>
     *          - Cb + (2 * Cs - 1) * (D(Cb) - Cb)      if Cs > 0.5 <br>
     *          where D(x) = <br>
     *          - ((16 * x - 12) * x + 4) * x           if x <= 0.25 <br>
     *          - sqrt(x)                               if x > 0.25
     */
    e_renderBlendSoftlight = 9,
    /**
     * @brief   Subtracts the darker of the two constituent colors from lighter colors.
     *
     * @details Here is the formula :<br>
     *          B(Cb, Cs) = |Cb - Cs|.
     */
    e_renderBlendDifference = 10,
    /**
     * @brief   Creates a color with the hue of the source color, and the saturation and luminosity of the backdrop color.
     *
     * @details Here is the formula :<br>
     *          B(Cb, Cs) = SetLum(SetSat(Cs, Sat(Cb)), Lum(Cb)).
     */
    e_renderBlendExclusion = 11,
    /**
     * @brief   Creates a color with the hue of the source color, and the saturation and luminosity of the backdrop color.
     *
     * @details Here is the formula :<br>
     *          B(Cb, Cs) = SetLum(SetSat(Cs, Sat(Cb)), Lum(Cb)).
     */
    e_renderBlendHue = 21,
    /**
     * @brief   Creates a color with the saturation of the source color, and the hue and luminosity of the backdrop color.
     *
     * @details Here is the formula :<br>
     *          B(Cb, Cs) = SetLum(SetSat(Cb, Sat(Cs)), Lum(Cb)).
     */
    e_renderBlendSaturation = 22,
    /**
     * @brief   Creates a color with the hue and saturation of the source color, and the luminosity of the backdrop color.
     *
     * @details Here is the formula :<br>
     *          B(Cb, Cs) = SetLum(Cs, Lum(Cb)).
     */
    e_renderBlendColor = 23,
    /**
     * @brief   Creates a color with the luminosity of the source color, and the hue and saturation of the backdrop color.
     *
     * @details Here is the formula :<br>
     *          B(Cb, Cs) = SetLum(Cb, Lum(Cs)).
     */
    e_renderBlendLuminosity = 24
};

/**
 * @brief   Enumeration for line join style.
 *
 * @details Values of this enumeration should be used alone.
 *          The line join style specifies the shape to be used at the corners of paths that are stroked.
 */
enum FS_LINEJOINTYPE {
    /**
     * @brief   Miter line join type.
     *
     * @details The outer edges of the strokes for the two segments are extended until they meet at an angle.
     */
    e_lineJoinMiter = 0,
    /**
     * @brief   Round line join type.
     *
     * @details An arc of a circle with a diameter equal to the line width is drawn around the point where the two segments meet,
     *          connecting the outer edges of the strokes for the two segments.
     */
    e_lineJoinRound = 1,
    /**
     * @brief   Bevel line join type.
     *
     * @details The two segments are finished with butt caps and the resulting notch beyond the end of the segments is filled with a triangle.
     */
    e_lineJoinBevel = 2
};

/**
 * @brief   Enumeration for line cap style.
 *
 * @details Values of this enumeration should be used alone.
 *          The line cap style specifies the shape to be used at the ends of open sub-paths (and dashes, if any)
 *           when they are stroked.
 */
enum FS_LINECAPTYPE {
    /**
     * @brief   The Butt Line Cap Type.
     *
     * @details The stroke is squared off at the endpoint of a path. There is no projection beyond the end of a path.
     */
    e_lineCapButt = 0,
    /**
     * @brief   The Round Line Cap Type.
     *
     * @details A semicircular arc with a diameter equal to the line width is drawn around the endpoint and filled in.
     */
    e_lineCapRound = 1,
    /**
     * @brief   The Projecting Square Line Cap Type.
     *
     * @details The stroke continues beyond the endpoint of the path for a distance equal to half the line width and is squared off.
     */
    e_lineCapSquare = 2
};

/**
 * @brief	Class for PDF graph states.
 */
@interface FSGraphState : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/**
 * @brief   Blend mode for transparent imaging model.
 *
 * @details Please refer to {@link FS_RENDERBLENDMODE::e_renderBlendNormal FS_RENDERBLENDMODE::e_renderBlendXXX} values and it should be one of these values.
 */
@property (nonatomic,assign) enum FS_RENDERBLENDMODE blendMode;
/**
 * @brief   Line width.
 *
 * @details It should be a non-negative number in PDF coordinate system. If 0 is set to this, it will be treated as 1 by default.
 */
@property (nonatomic,assign) float lineWidth;
/**
 * @brief   Line join style
 *
 * @details The line join style specifies the shape to be used at the corners of paths that are stroked.
 *          Please refer to {@link FS_LINEJOINTYPE::e_lineJoinMiter FS_LINEJOINTYPE::e_lineJoinXXX} values and it should be one of these values.
 */
@property (nonatomic,assign) enum FS_LINEJOINTYPE lineJoin;
/**
 * @brief   The miter limit for line join.
 *
 * @details When two line segments meet at a sharp angle and mitered joins have been specified as the line join style,
 *          it is possible for the miter to extend far beyond the thickness of the line stroking the path.
 *          The miter limit imposes a maximum on the ratio of the miter length to the line width.
 *          When the limit is exceeded, the join is converted from a miter to a bevel.<br>
 *          Please refer to <PDF Reference 1.7> P217 "Miter Limit" for more details.
 */
@property (nonatomic,assign) float miterLimit;
/**
 * @brief   Line cap style.
 *
 * @details The line cap style specifies the shape to be used at the ends of open sub-paths (and dashes, if any) when they are stroked.
 *          Please refer to {@link FS_LINECAPTYPE::e_lineCapButt FS_LINECAPTYPE::e_lineCapXXX} values and it should be one of these values.
 */
@property (nonatomic,assign) enum FS_LINECAPTYPE lineCap;
/** @brief  Dash phase for line dash pattern.*/
@property (nonatomic,assign) float dashPhase;
/**
 * @brief   Set a NSArray object that represents the dash patterns, with at most 16 valid elements.
 *
 * @param[in]   value   Dash patterns.
 *
 * @details The value of useful elements in this array should not be negative.<br>
 *          In this array, an element with integer value -1 means that all the elements before this element are useful,
 *          and this element with the rest will be ignored.<br>
 *          If no element's value is -1, that means all of 16 elements are useful.
 */
@property (nonatomic,retain) NSArray<NSNumber *>* dashes;

/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;

/**
 * @brief   Set value.
 *
 * @param[in]   blendMode       Blend mode for transparent imaging model.
 *                              Please refer to {@link FS_RENDERBLENDMODE::e_renderBlendNormal FS_RENDERBLENDMODE::e_renderBlendXXX} values and it should be one of these values.
 * @param[in]   lineWidth       Line width. If 0 is set to this, it will be treated as 1 by default.
 * @param[in]   lineJoin        Line join style.
 *                              Please refer to {@link FS_LINEJOINTYPE::e_lineJoinMiter FS_LINEJOINTYPE::e_lineJoinXXX} values and it should be one of these values.
 * @param[in]   miterLimit      The miter limit for line join.
 * @param[in]   lineCap         Line cap style.
 *                              Please refer to {@link FS_LINECAPTYPE::e_lineCapButt FS_LINECAPTYPE::e_lineCapXXX} values and it should be one of these values.
 * @param[in]   dashPhase       Dash phase for line dash pattern.
 * @param[in]   dashes          A float array that represents the dash patterns, with at most 16 valid elements.
 *                              The value of useful elements in this array should not be negative.<br>
 *                              In this array, an element with integer value -1 means that all the elements before this element are useful,
 *                              and this element with the rest will be ignored.<br>
 *                              If no element's value is -1, that means all of 16 elements are useful.
 *
 * @return  None.
 */
-(void)set: (enum FS_RENDERBLENDMODE)blendMode lineWidth: (float)lineWidth lineJoin: (enum FS_LINEJOINTYPE)lineJoin miterLimit: (float)miterLimit lineCap: (enum FS_LINECAPTYPE)lineCap dashPhase: (float)dashPhase dashes: (NSArray<NSNumber *>*)dashes;

-(id)init;

-(void)dealloc;

@end

/**
 * @brief	Class to access marked content.
 *
 * @details	To get a marked content object, please use function {@link FSPDFGraphicsObject::getMarkedContent}.
 *			Please refer to Section 10.5 in <PDF Reference 1.7> which describes Marked Content of PDF Content Stream.
 *
 * @see	FSPDFGraphicsObject
 */
@interface FSPDFMarkedContent : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief   Check whether current marked content object has a specified marked content item or not.
 *
 * @param[in]   tagName     The tag name to be checked, in UTF-8 encoding.
 *
 * @return  <b>YES</b> means current marked content object has the specified marked content item.
 *          <b>NO</b> means current marked content object has the specified marked content item.
 *
 * @exception   e_errParam  Value of any input parameter is invalid.
 * @exception   e_errFormat Any input UTF-8 string parameter is not in UTF-8 encoding.
 */
-(BOOL)hasTag: (NSString *)tagName;
/**
 * @brief   Get the count of marked content items.
 *
 * @details A marked content object may be nested one within another, and this function is used to get the count of marked content items
 *          in the current marked content sequence.
 *
 * @return  The count of marked content items.
 */
-(int)getItemCount;
/**
 * @brief   Get the tag name of a marked content item, specified by index.
 *
 * @details A marked content object may be nested one within another, and this function is used to get the count of marked content items
 *          in the current marked content sequence.
 *
 * @param[in]   index   Item index. Valid range: from 0 to (<i>count</i>-1).
 *                      <i>count</i> is returned by function {@link FSPDFMarkedContent::getItemCount}.
 *
 * @return  The tag name, in UTF-8 encoding.
 *
 * @exception   e_errParam  Value of any input parameter is invalid.
 */
-(NSString *)getItemTagName: (int)index;
/**
 * @brief   Get marked-content identifier (MCID) of a marked content item, specified by index.
 *
 * @param[in]   index   Item index. Valid range: from 0 to (<i>count</i>-1).
 *                      <i>count</i> is returned by function {@link FSPDFMarkedContent::getItemCount}.
 *
 * @return  The MCID value.
 *          A negative number means that the specified marked content item does not have a MCID.
 *
 * @exception   e_errParam  Value of any input parameter is invalid.
 */
-(int)getItemMCID: (int)index;
/**
 * @brief   Get the property dictionary of a marked content item, specified by index.
 *
 * @param[in]   index   Item index. Valid range: from 0 to (<i>count</i>-1).
 *                      <i>count</i> is returned by function {@link FSPDFMarkedContent::getItemCount}.
 *
 * @return  A ::FSPDFDictionary represents the property dictionary.
 *          <b>nil</b> means no property dictionary.
 *
 * @exception   e_errParam  Value of any input parameter is invalid.
 */
-(FSPDFDictionary*)getItemPropertyDict: (int)index;
/**
 * @brief   Add a new marked content item.
 *
 * @param[in]   tagName         New tag name, in UTF-8 encoding. It should not be nil or an empty string.
 *                              If parameter <i>tagName</i> exists in current marked content object, it cannot be added to current marked content object again.
 * @param[in]   propertyDict    A property dictionary.
 *                              <b>nil</b> means the new marked content item will not have a property dictionary.
 *
 * @return  The index of the newly added marked content item.
 *          If there is any error, this function will return -1.
 *
 * @exception   e_errParam      Value of any input parameter is invalid.
 * @exception   e_errFormat     Any input UTF-8 string parameter is not in UTF-8 encoding.
 * @exception   e_errConflict   Input tag name has already existed and cannot be added again.
 * @exception   e_errUnknown    Any unknown error occurs.
 */
-(int)addItem: (NSString *)tagName propertyDict: (FSPDFDictionary*)propertyDict;
/**
 * @brief   Remove a marked content item by tag name.
 *
 * @param[in]   tagName     Tag name, in UTF-8 encoding. It should not be nil or an empty string.
 *
 * @return  <b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception   e_errParam      Value of any input parameter is invalid.
 * @exception   e_errFormat     Any input UTF-8 string parameter is not in UTF-8 encoding.
 * @exception   e_errUnknown    Any unknown error occurs.
 */
-(BOOL)removeItem: (NSString *)tagName;
-(id)init;

-(void)dealloc;

@end

/**
 * @brief	Class to access a PDF graphics object.
 *
 * @details	A PDF page's content usually consists of a sequence of graphics objects.
 *			Each graphics object contains its state information, data and instructions for rendering.
 *			Class ::FSPDFGraphicsObject is the base class for all types of PDF graphics objects. It offers the base functions to access graphics object's common properties.
 *			For concrete graphics object types, please refer to derived classes. <br>
 *			To get or insert/remove a graphics object, please refer to class ::FSPDFGraphicsObjects.<br>
 *			If any change is done to a PDF graphics object, please remember to call function {@link FSPDFGraphicsObjects::generateContent}
 *			for the ::FSPDFGraphicsObjects object (to which current object belongs) before saving document.
 *			(If the ::FSPDFGraphicsObjects object is just a PDF page, just call function {@link FSPDFPage::generateContent}.)<br>
 *			Please refer to comment of function {@link FSPDFGraphicsObjects::generateContent} and {@link FSPDFPage::generateContent} for more details.
 *
 * @see	FSPDFGraphicsObjects
 * @see	FSPDFPage
 */
@interface FSPDFGraphicsObject : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief   Get the type of current graphics object.
 *
 * @return  Graphics object type.
 *          Please refer to {@link FS_GRAPHICSOBJECTTYPE::e_graphicsObjTypeText FS_GRAPHICSOBJECTTYPE::e_graphicsObjTypeXXX} values and it would be one of these values
 *          except {@link FS_GRAPHICSOBJECTTYPE::e_graphicsObjTypeAll}.
 */
-(enum FS_GRAPHICSOBJECTTYPE)getType;
/**
 * @brief   Get the rectangle of current graphics object.
 *
 * @return  Rectangle of current graphics object.
 *          If there is any error, this function will return a ::FSRectF with all values 0.
 */
-(FSRectF*)getRect;
/**
 * @brief   Check whether current graphics object has transparency or not.
 *
 * @return  <b>YES</b> means current graphics object has transparency, while <b>NO</b> means not.
 */
-(BOOL)hasTransparency;
/**
 * @brief   Get the stroke color.
 *
 * @details Text, path, and form XObject can have this property.
 *
 * @return  Color value, in format 0xAARRGGBB.
 */
-(unsigned int)getStrokeColor;
/**
 * @brief   Get the fill color.
 *
 * @details Text, path, and form XObject can have this property.
 *
 * @return  Color value, in format 0xAARRGGBB.
 */
-(unsigned int)getFillColor;
/**
 * @brief   Set the stroke color.
 *
 * @details Text, path, and form XObject can have this property.
 *          If current graphics object is {@link FS_GRAPHICSOBJECTTYPE::e_graphicsObjTypeText} and the text mode is {@link FS_TEXTMODE::e_textModeFill},
 *          the stroke color will not effect for the text graphics object.<br>
 *          If try to set stroke color for rest unsupported types, {@link FS_ERRORCODE::e_errUnsupported} will be thrown.
 *
 * @param[in]   color   New color value, in format 0xAARRGGBB.
 *
 * @return  None.
 *
 * @exception   e_errUnsupported    Not support to set this property for graphics object in current type.
 */
-(void)setStrokeColor: (unsigned int)color;
/**
 * @brief   Set the fill color.
 *
 * @details Text, path, and form XObject can have this property.
 *          If try to set fill color for rest unsupported types, {@link FS_ERRORCODE::e_errUnsupported} will be thrown.<br>
 *
 * @param[in]   color   New color value, in format 0xAARRGGBB.
 *
 * @return  None.
 *
 * @exception   e_errUnsupported    Not support to set this property for graphics object in current type.
 */
-(void)setFillColor: (unsigned int)color;
/**
 * @brief   Get matrix.
 *
 * @return  Matrix value.
 *          If there is any error, this function will return a ::FSMatrix with all values 0.
 */
-(FSMatrix*)getMatrix;
/**
 * @brief   Set matrix.
 *
 * @param[in]   matrix      New matrix value.
 *
 * @return  None.
 *
 * @exception   e_errUnknown        Any unknown error occurs.
 */
-(void)setMatrix: (FSMatrix*)matrix;
/**
 * @brief   Transform current graphics object.
 *
 * @details After this function finishes successfully, please call function {@link FSPDFPage::generateContent} before saving current page;
 *          otherwise the change of current graphics object could not be saved to document.
 *
 * @param[in]   matrix          Transform matrix.
 * @param[in]   needTransformClipPath   <b>YES</b> means to transform clip path with current graphics object.
 *                              <b>NO</b> means to transform current graphics object only.
 *
 * @return  <b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)transform: (FSMatrix*)matrix needTransformClipPath: (BOOL)needTransformClipPath;
/**
 * @brief   Clone a new graphics object.
 *
 * @details Newly cloned graphics object is related to the same page with current graphics object by default.
 *          Newly cloned graphics object can only be used inside the PDF file which contains current graphics object.
 *
 * @return  Cloned graphics object.
 *          If there is any error, this function will return <b>nil</b>.<br>
 */
-(FSPDFGraphicsObject*)clone;
/**
 * @brief   Get graph state.
 *
 * @details Form XObjet, path and text object can have this property.
 *
 * @return  Graph state.
 */
-(FSGraphState*)getGraphState;
/**
 * @brief   Set graph state.
 *
 * @details Form XObjet, path and text object can have this property.
 *          If try to set graph state to rest unsupported types, {@link FS_ERRORCODE::e_errUnsupported} will be thrown.<br>
 *
 * @param[in]   graphState  New graph state.
 *
 * @return  None.
 *
 * @exception   e_errUnsupported    Not support to set this property for graphics object in current type.
 * @exception   e_errOutOfMemory    Out-of-memory error occurs.
 */
-(void)setGraphState: (FSGraphState*)graphState;
/**
 * @brief   Get the count of path clip.
 *
 * @return  Count of path clip.
 */
-(int)getClipPathCount;
/**
 * @brief   Get a path clip by index.
 *
 * @param[in]   index   Path clip index. Valid range: from 0 to (<i>count</i>-1).
 *                      <i>count</i> is returned by function {@link FSPDFGraphicsObject::getClipPath:}.
 *
 * @return  Path data.
 *          If there is any error, this function will return <b>nil</b>.
 *
 * @exception   e_errParam          Value of any input parameter is invalid.
 * @exception   e_errOutOfMemory    Out-of-memory error occurs.
 */
-(FSPDFPath*)getClipPath: (int)index;
/**
 * @brief   Get the fill mode of a path clip by index.
 *
 * @param[in]   index   Path clip index. Valid range: from 0 to (<i>count</i>-1).
 *                      <i>count</i> is returned by function {@link FSPDFGraphicsObject::getClipPath:}.
 *
 * @return  Fill mode.
 *          Please refer to {@link FS_FILLMODE::e_fillModeNone FS_FILLMODE::e_fillModeXXX} values and it would be one of these values.
 *
 * @exception   e_errParam  Value of any input parameter is invalid.
 */
-(enum FS_FILLMODE)getClipPathFillMode: (int)index;
/**
 * @brief   Add a path for clipping.
 *
 * @param[in]   path        Path data to be added to current graphics object.
 * @param[in]   fillMode    Fill mode for parameter <i>path</i>.
 *                          Please refer to {@link FS_FILLMODE::e_fillModeNone FS_FILLMODE::e_fillModeXXX} values and it should be one of these values.
 *
 * @return  <b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception   e_errParam     Value of input parameter is invalid.
 */
-(BOOL)addClipPath: (FSPDFPath*)path fillMode: (enum FS_FILLMODE)fillMode;
/**
 * @brief   Remove a path clip by index.
 *
 * @param[in]   index   Path clip index. Valid range: from 0 to (<i>count</i>-1).
 *                      <i>count</i> is returned by function {@link FSPDFGraphicsObject::getClipPath:}.
 *
 * @return  <b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception   e_errParam  Value of any input parameter is invalid.
 */
-(BOOL)removeClipPath: (int)index;
/**
 * @brief   Get the count of text clip.
 *
 * @return  Count of text clip.
 */
-(int)getClipTextObjectCount;
/**
 * @brief   Get the text object of a text clip by index.
 *
 * @param[in]   index   Text clip index. Valid range: from 0 to (<i>count</i>-1).
 *                      <i>count</i> is returned by function {@link FSPDFGraphicsObject::getClipTextObjectCount}.
 *
 * @return  A text graphics object.
 *          If there is any error, this function will return <b>nil</b>.
 *
 * @exception   e_errParam  Value of any input parameter is invalid.
 */
-(FSPDFTextObject*)getClipTextObject: (int)index;
/**
 * @brief   Add text object for clipping.
 *
 * @param[in]   textObj     Text object to be added for clipping.
 *
 * @return  <b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception   e_errParam  Value of any input parameter is invalid.
 */
-(BOOL)addClipTextObject: (FSPDFTextObject*)textObj;
/**
 * @brief   Remove a text clip by index for clipping.
 *
 * @param[in]   index   Path clip index. Valid range: from 0 to (<i>count</i>-1).
 *                      <i>count</i> is returned by function {@link FSPDFGraphicsObject::getClipTextObjectCount}.
 *
 * @return  <b>YES</b> means success, while <b>NO</b> means failure.
 *
 * @exception   e_errParam      Value of any input parameter is invalid.
 * @exception   e_errUnknown    Any unknown error occurs.
 */
-(BOOL)removeClipTextObject: (int)index;
/**
 * @brief   Get clip rectangle.
 *
 * @return  Clip rectangle.
 *          A ::FSRectF with all values 0 means no clip rectangle.
 */
-(FSRectF*)getClipRect;
/**
 * @brief   Set clip rectangle.
 *
 * @details New clip rectangle will be set with fill mode {@link FS_FILLMODE::e_fillModeWinding} by default.
 *
 * @param[in]   clipRect    New clip rectangle.
 *
 * @return  None.
 */
-(void)setClipRect: (FSRectF*)clipRect;
/**
 * @brief   Clear all clips.
 *
 * @return  <b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)clearClips;
/**
 * @brief   Get marked content object
 *
 * @return  A marked content object.
 */
-(FSPDFMarkedContent*)getMarkedContent;
-(id)init;

-(void)dealloc;

@end

/**
 * @brief   Enumeration for text rendering mode.
 *
 * @details Values of this enumeration should be used alone.
 */
enum FS_TEXTMODE {
    /** @brief  Text mode: fill text. */
    e_textModeFill = 0,
    /** @brief  Text mode: stroke text. */
    e_textModeStroke = 1,
    /** @brief  Text mode: fill and stroke text. */
    e_textModeFillStroke = 2,
    /** @brief  Text mode: neither fill nor stroke text, to make it invisible. */
    e_textModeInvisible = 3,
    /** @brief  Text mode: fill text and add to path for clipping. */
    e_textModeFillClip = 4,
    /** @brief  Text mode: stroke text and add to path for clipping. */
    e_textModeStrokeClip = 5,
    /** @brief  Text mode: fill and stroke text, and add to path for clipping. */
    e_textModeFillStrokeClip = 6,
    /** @brief  Text mode: add text to path for clipping. */
    e_textModeClip = 7
};

/**
 * @brief	Class for PDF text states
 */
@interface FSPDFTextState : NSObject
{
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    void *swigCPtr;
    /** @brief SWIG proxy related property, it's deprecated to use it. */
    BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief   Set value.
 *
 * @param[in]   version         Version of this structure, which is used to decide which members are useful. Currently, only 1 is valid.
 * @param[in]   font            (Version 1) New font object. It should not be <b>nil</b>.
 * @param[in]   fontSize        (Version 1) New font size. It should be above 0.
 * @param[in]   charSpace       (Version 1) Character spacing.
 * @param[in]   wordSpace       (Version 1) Word spacing (only apply to space character).
 * @param[in]   textMode        (Version 1) Text rendering mode.
 *                              Please refer to {@link FS_TEXTMODE::e_textModeFill FS_TEXTMODE::e_textModeXXX} values and it should be one of these values.
 * @param[in]   originPosition  (Version 1) The origin point, in PDF coordinate system.
 * @param[in]   textMatrix   (Version 1) Text transformation matrix.
 *
 * @return  None.
 */
-(void)set: (unsigned int)version font: (FSFont*)font fontSize: (float)fontSize charSpace: (float)charSpace wordSpace: (float)wordSpace textMode: (enum FS_TEXTMODE)textMode originPosition: (FSPointF*)originPosition textMatrix: (NSArray<NSNumber*>*)textMatrix;
/**
 * @brief   Version of this structure. Currently, only 1 is valid.
 *
 * @details This structure may be extended in the future. So the version is used to separate the different extended members.
 */
@property (nonatomic,assign) unsigned int version;
/** @brief   Font object.*/
@property (nonatomic,retain) FSFont* font;
/** @brief   Font size. If valid, it should be above 0.*/
@property (nonatomic,assign) float fontSize;
/**
 * @brief   Character spacing.
 *
 * @details For horizontal writing, a positive value has the effect of expanding the distance between glyphs,
 *          whereas for vertical writing, a negative value has this effect.
 */
@property (nonatomic,assign) float charSpace;
/**
 * @brief   Word spacing (only apply to space character).
 *
 * @details For horizontal writing, a positive value has the effect of increasing the spacing between words.
 *          For vertical writing, a positive value decreases the spacing between words (and a negative value increases it),
 *          since vertical coordinates increase from bottom to top.
 *
 * @note    This will not take effect if {@link FSPDFTextState::font} is an embedded font.
 */
@property (nonatomic,assign) float wordSpace;
/**
 * @brief   Text rendering mode.
 *
 * @details Please refer to {@link FS_TEXTMODE::e_textModeFill FS_TEXTMODE::e_textModeXXX} values and it should be one of these values.
 */
@property (nonatomic,assign) enum FS_TEXTMODE textMode;
/** @brief   The origin point, in PDF coordinate system.*/
@property (nonatomic,retain) FSPointF* originPosition;
/** @brief   Text transformation matrix.*/
@property (nonatomic,retain) NSArray<NSNumber*>* textMatrix;

-(id)init;

-(void)dealloc;

@end

/**
 * @brief   Class to access a text graphics object.
 *
 * @details Text graphics object is a kind of PDF graphics object, so class ::FSPDFTextObject is derived from class ::FSPDFGraphicsObject.
 *          It offers functions to access text graphics object's data. <br>
 *          To create a new text graphics object, please use function {@link FSPDFTextObject::create} and then use setting methods
 *          to set information to the new text graphics object.
 *
 * @see FSPDFGraphicsObject
 */
@interface FSPDFTextObject : FSPDFGraphicsObject
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief   Create a new text graphics object.
 *
 * @return  A new text graphics object.<br>
 *          If the newly created text graphics object is not inserted to any page or other objects.
 *
 * @exception   e_errOutOfMemory    Out-of-memory error occurs.
 */
+(FSPDFTextObject*)create;
/**
 * @brief   Get text string.
 *
 * @return  Text string, in UTF-8 encoding.
 *
 * @exception   e_errInvalidType    Type of current graphics object is incorrect.
 * @exception   e_errUnknown        Any unknown error occurs.
 */
-(NSString *)getText;
/**
 * @brief   Set text string.
 *
 * @param[in]   text    New text string, in UTF-8 encoding.
 *
 * @return  None.
 *
 * @note    Before setting text, please ensure that current text graphics object has valid font (a part of FSPDFTextState).
 *          If not, please call function {@link FSPDFTextObject::setTextState:textState:isItalic:weight:} to set valid font first; othewise setting text will fail.
 *
 * @exception   e_errFormat         Any input UTF-8 string parameter is not in UTF-8 encoding.
 * @exception   e_errInvalidType    Type of current graphics object is incorrect.
 * @exception   e_errOutOfMemory    Out-of-memory error occurs.
 * @exception   e_errUnknown        Any unknown error occurs.
 */
-(void)setText: (NSString *)text;
/**
 * @brief   Get text state information.
 *
 * @param[in]   page    PDF page. Please ensure that current graphics object just belongs to this page.
 *
 * @return  Text state information.
 *
 * @exception   e_errParam      Value of any input parameter is invalid.
 * @exception   e_errInvalidType    Type of current graphics object is incorrect.
 */
-(FSPDFTextState*)getTextState: (FSPDFPage*)page;
/**
 * @brief   Set text state information.
 *
 * @param[in]   page        PDF page. Please ensure that current graphics object just belongs to this page.
 * @param[in]   textState   New text state information.
 * @param[in]   isItalic    <b>YES</b> means the text of current graphics object is italic, while <b>NO</b> means not.
 * @param[in]   weight      Original font weight. If the value is larger than 500, that means to use bold.
 *
 * @return  None.
 *
 * @exception   e_errInvalidType    Type of current graphics object is incorrect.
 * @exception   e_errOutOfMemory    Out-of-memory error occurs.
 * @exception   e_errUnknown        Any unknown error occurs.
 */
-(void)setTextState: (FSPDFPage*)page textState: (FSPDFTextState*)textState isItalic: (BOOL)isItalic weight: (int)weight;
-(id)init;

-(void)dealloc;

@end

/**
 * @brief   Class to access a path graphics object.
 *
 * @details Path graphics object is a kind of PDF graphics object, so class ::FSPDFPathObject is derived from class ::FSPDFGraphicsObject.
 *          It offers functions to access path graphics object's data. <br>
 *          To create a new path graphics object, please use function {@link FSPDFPathObject::create} and then use setting methods
 *          to set information to the new path graphics object.
 *
 * @see FSPDFGraphicsObject
 */
@interface FSPDFPathObject : FSPDFGraphicsObject
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief   Create a path graphics object.
 *
 * @return  A new path graphics object.<br>
 *          If the newly created path graphics object is not inserted to any page or other objects.
 *
 * @exception   e_errOutOfMemory    Out-of-memory error occurs.
 */
+(FSPDFPathObject*)create;
/**
 * @brief   Get fill mode.
 *
 * @return  Fill mode.
 *          Please refer to {@link FS_FILLMODE::e_fillModeNone FS_FILLMODE::e_fillModeXXX} values and it would be one of these values.
 *
 * @exception   e_errInvalidType    Type of current graphics object is incorrect.
 */
-(enum FS_FILLMODE)getFillMode;
/**
 * @brief   Set fill mode.
 *
 * @param[in]   fillMode    Fill mode.
 *                          Please refer to {@link FS_FILLMODE::e_fillModeNone FS_FILLMODE::e_fillModeXXX} values and it would be one of these values.
 *
 * @return  None.
 *
 * @exception   e_errParam          Value of any input parameter is invalid.
 * @exception   e_errInvalidType    Type of current graphics object is incorrect.
 */
-(void)setFillMode: (enum FS_FILLMODE)fillMode;
/**
 * @brief   Get stroke state
 *
 * @return  The stroke state:
 *          <ul>
 *          <li><b>YES</b> means current path graphics object is stroked.</li>
 *          <li><b>NO</b> means current path graphics object is not stroked.</li>
 *          </ul>
 *
 * @exception   e_errInvalidType    Type of current graphics object is incorrect.
 */
-(BOOL)getStrokeState;
/**
 * @brief   Set stroke state.
 *
 * @param[in]   isStroke    <b>YES</b> means current path graphics object is to be stroked.
 *                          <b>NO</b> means current path graphics object is not to be stroked.
 *
 * @return  None.
 *
 * @exception   e_errInvalidType    Type of current graphics object is incorrect.
 */
-(void)setStrokeState: (BOOL)isStroke;
/**
 * @brief   Get the path data.
 *
 * @return  Path data.
 *          If there is any error, this function will return <b>nil</b>.
 *
 * @exception   e_errInvalidType    Type of current graphics object is incorrect.
 * @exception   e_errOutOfMemory        Out-of-memory error occurs.
 */
-(FSPDFPath*)getPathData;
/**
 * @brief   Set the path data.
 *
 * @param[in]   pathData    New path data.
 *
 * @return  None.
 *
 * @exception   e_errParam          Value of any input parameter is invalid.
 * @exception   e_errInvalidType    Type of current graphics object is incorrect.
 */
-(void)setPathData: (FSPDFPath*)pathData;
-(id)init;

-(void)dealloc;

@end


/**
 * @brief   Class to access a text graphics object.
 *
 * @details A form XObject is not only a graphics object, but also a container. A form XObject consists of a set of graphics objects or sub form XObjects.
 *          Form XObject is a kind of PDF graphics object, so class ::FSPDFFormXObject is derived from class ::FSPDFGraphicsObject.
 *          It offers functions to access form XObject's data. <br>
 *          To create a new form XObject graphics object, please use function {@link FSPDFPathObject::create} and then import page content to the new form XObject,
 *          or insert new graphics object to form XObject through ::FSPDFGraphicsObjects object returned by function {@link FSPDFFormXObject::getGraphicsObjects}.
 *
 * @see FSPDFGraphicsObject
 */
@interface FSPDFFormXObject : FSPDFGraphicsObject
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief   Create a form XObject.
 *
 * @param[in]   pdfDoc      PDF document.
 *                          The new image object should be inserted to one page of this PDF document.
 *
 * @return  A new form XObject.<br>
 *          If the newly created form XObject is not inserted to any page or other objects.
 *
 * @exception   e_errParam          Value of any input parameter is invalid.
 * @exception   e_errOutOfMemory    Out-of-memory error occurs.
 */
+(FSPDFFormXObject*)create: (FSPDFDoc*)pdfDoc;
/**
 * @brief   Get stream.
 *
 * @return  A ::FSPDFStream that represents the stream.
 *          If there is any error, this function will return <b>nil</b>.
 *
 * @exception   e_errInvalidType    Type of current graphics object is incorrect.
 */
-(FSPDFStream*)getStream;
/**
 * @brief   Get graphics objects, to manage all the graphic objects in this container.
 *
 * @return  A ::FSPDFGraphicsObjects object.
 *
 * @exception   e_errInvalidType    Type of current graphics object is incorrect.
 * @exception   e_errOutOfMemory    Out-of-memory error occurs.
 */
-(FSPDFGraphicsObjects*)getGraphicsObjects;
/**
 * @brief   Import page content of a specified PDF page to current form XObject.
 *
 * @details If this function succeeds, the boundary box of current form XObject will be the same as page's size.
 *
 * @param[in]   srcPage             Source page, whose content will be imported to current form XObject.
 * @param[in]   isAnnotsIncluded    <b>YES</b> means annotations should be included in the content of parameter <i>srcPage</i>.
 *                                  <b>NO</b> means annotations should be ignored from the content of parameter <i>srcPage</i>.
 *
 * @return  <b>YES</b> means success, while <b>NO</b> means failure.
 *
 *
 * @exception   e_errInvalidType    Type of current graphics object is incorrect.
 * @exception   e_errOutOfMemory    Out-of-memory error occurs.
 * @exception   e_errUnknown        Any unknown error occurs.
 */
-(BOOL)importPageContent: (FSPDFPage*)srcPage isAnnotsIncluded: (BOOL)isAnnotsIncluded;
-(id)init;

-(void)dealloc;

@end

/**
 * @brief   Class to access a shading graphics object.
 *
 * @details Shading graphics object is a kind of PDF graphics object, so class ::FSPDFShadingObject is derived from class ::FSPDFGraphicsObject.
 *          It offers functions to access shading graphics object's data.
 *
 * @see FSPDFGraphicsObject
 */
@interface FSPDFShadingObject : FSPDFGraphicsObject
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief   Get the PDF object, a PDF dictionary or a PDF stream object.
 *
 * @return  A ::FSPDFObject. It should be a PDF dictionary or a PDF stream object.
 *          If there is any error, this function will return <b>nil</b>.
 *
 * @exception   e_errInvalidType    Type of current graphics object is incorrect.
 */
-(FSPDFObject*)getPDFObject;
-(id)init;

-(void)dealloc;

@end

/**
 * @brief   Enumeration for image color space.
 *
 * @details Values of this enumeration should be used alone.
 */
enum FS_IMAGECOLORSPACE {
    /** @brief  Color space: Invalid. */
    e_imgColorSpaceInvalid = 0,
    /** @brief  Color space: DeviceGray. */
    e_imgColorSpaceDeviceGray = 1,
    /** @brief  Color space: DeviceRGB. */
    e_imgColorSpaceDeviceRGB = 2,
    /** @brief  Color space: DeviceCMYK. */
    e_imgColorSpaceDeviceCMYK = 3,
    /** @brief  Color space: CalGray. */
    e_imgColorSpaceCalGray = 4,
    /** @brief  Color space: CalRGB. */
    e_imgColorSpaceCalRGB = 5,
    /** @brief  Color space: Lab. */
    e_imgColorSpaceLab = 6,
    /** @brief  Color space: Separation. */
    e_imgColorSpaceSeparation = 8,
    /** @brief  Color space: DeviceN. */
    e_imgColorSpaceDeviceN = 9,
    /** @brief  Color space: Pattern. */
    e_imgColorSpacePattern = 11,
    /** @brief  Color space: ICCBased DeviceGray. */
    e_imgColorSpaceICCBasedDeviceGray = 12,
    /** @brief  Color space: ICCBased DeviceRGB. */
    e_imgColorSpaceICCBasedDeviceRGB = 13,
    /** @brief  Color space: ICCBased DeviceCMYK. */
    e_imgColorSpaceICCBasedDeviceCMYK = 14
};

/**
 * @brief   Class to access a image graphics object.
 *
 * @details Image graphics object is a kind of PDF graphics object, so class ::FSPDFImageObject is derived from class ::FSPDFGraphicsObject.
 *          It offers functions to access image graphics object's data. <br>
 *          To create a new image graphics object, please use function {@link FSPDFImageObject::create:} and then use setting methods
 *          to set information to the new image graphics object.
 *
 * @see FSPDFGraphicsObject
 */
@interface FSPDFImageObject : FSPDFGraphicsObject
-(void*)getCptr;
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief   Create a new empty image graphics object.
 *
 * @param[in]   pdfDoc      PDF document.
 *                          The new image graphics object should be inserted to one page of this PDF document then.
 *
 * @return  A new image object.<br>
 *          If the newly created image graphics object is not inserted to any page or other objects.
 *
 * @exception   e_errParam          Value of any input parameter is invalid.
 * @exception   e_errOutOfMemory    Out-of-memory error occurs.
 */
+(FSPDFImageObject*)create: (FSPDFDoc*)pdfDoc;
/**
 * @brief   Set bitmap.
 *
 * @param[in]   bitmap  New bitmap.
 * @param[in]   mask    Mask bitmap. It can be <b>nil</b>.
 *                      If this is valid, its format should be {@link FS_DIBFORMAT::e_dib8bppMask}. <br>
 *                      This is useful only when parameter <i>bitmap</i> does not have an alpha channel.
 *
 * @return  None
 *
 * @exception   e_errInvalidType    Type of current graphics object is incorrect.
 */
-(void)setBitmap: (FSBitmap*)bitmap mask: (FSBitmap*)mask;
/**
 * @brief   Clone the bitmap.
 *
 * @details Currently, only support to clone bitmap in following formats:<br>
 *          {@link FS_DIBFORMAT::e_dib8bppMask}, {@link FS_DIBFORMAT::e_dibRgb}, {@link FS_DIBFORMAT::e_dibRgb32},
 *          {@link FS_DIBFORMAT::e_dibArgb}.<br>
 *          For other unsupported DIB format, this function will return <b>nil</b>.
 *
 * @param[in]   page                PDF page. Please ensure that current image graphics object just belongs to this page.
 *
 * @return  The new cloned bitmap object.
 *          <b>nil</b> means the bitmap's DIB format is not supported.
 *
 * @exception   e_errParam          Value of input parameter is invalid.
 * @exception   e_errOutOfMemory    Out-of-memory error occurs.
 * @exception   e_errInvalidType    Type of current graphics object is incorrect.
 * @exception   e_errUnknown        Any unknown error occurs.
 */
-(FSBitmap*)cloneBitmap: (FSPDFPage*)page;
/**
 * @brief   Get color space.
 *
 * @return  Color space.
 *          Please refer to {@link FS_IMAGECOLORSPACE::e_imgColorSpaceDeviceGray FS_IMAGECOLORSPACE::e_imgColorSpaceXXX} values
 *          and it would be one of these values.
 *
 * @exception   e_errInvalidType    Type of current graphics object is incorrect.
 * @exception   e_errUnknown        Any unknown error occurs.
 */
-(enum FS_IMAGECOLORSPACE)getColorSpace;
/**
 * @brief   Get image stream.
 *
 * @return  A ::FSPDFStream that represents the image stream.
 *          If there is any error, this function will return <b>nil</b>.
 *
 * @exception   e_errInvalidType    Type of current graphics object is incorrect.
 */
-(FSPDFStream*)getStream;
-(id)init;

-(void)dealloc;

@end
